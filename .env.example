# Server Configuration
NODE_ENV=development
PORT=3000
HOST=0.0.0.0
BASE_URL=http://localhost:3000

# Database Configuration
# PostgreSQL connection string
# Format: postgresql://username:password@host:port/database
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/af_auth

# Database Connection Pool Settings
DB_POOL_MIN=2
DB_POOL_MAX=10
DB_CONNECTION_TIMEOUT_MS=5000
DB_MAX_RETRIES=3
DB_RETRY_DELAY_MS=1000

# Database SSL/TLS Configuration
# Enable SSL for database connections (recommended for production)
# Set to 'true' for production deployments, 'false' for local development
DB_SSL_ENABLED=false
# Whether to reject connections with invalid SSL certificates
# Set to 'true' in production, can be 'false' for development with self-signed certs
DB_SSL_REJECT_UNAUTHORIZED=true
# Optional: CA certificate for SSL verification (base64-encoded)
# DB_SSL_CA=base64_encoded_ca_certificate
# Optional: Client certificate for mutual TLS (base64-encoded)
# DB_SSL_CERT=base64_encoded_client_certificate
# Optional: Client key for mutual TLS (base64-encoded)
# DB_SSL_KEY=base64_encoded_client_key

# Logging Configuration
LOG_LEVEL=info
# Set to 'true' for pretty printing in development
LOG_PRETTY=true

# GitHub OAuth Configuration
# GitHub App credentials for OAuth authentication
# See docs/github-app-setup.md for setup instructions

# GitHub App ID (found in app settings)
GITHUB_APP_ID=your_github_app_id

# GitHub App Installation ID (found after installing the app)
GITHUB_INSTALLATION_ID=your_installation_id

# GitHub App Private Key (base64-encoded PEM format)
# Generate in GitHub App settings, then base64 encode:
#   base64 -w 0 private-key.pem  (Linux)
#   base64 -i private-key.pem -o - (macOS)
GITHUB_APP_PRIVATE_KEY=base64_encoded_github_app_private_key

# GitHub OAuth Client credentials (same as App Client ID/Secret)
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret
GITHUB_CALLBACK_URL=http://localhost:3000/auth/github/callback

# GitHub Token Encryption
# REQUIRED: Encryption key for GitHub access/refresh tokens stored in database
# Must be at least 32 characters long (recommend 64+ characters)
# Generate with: openssl rand -hex 32
# SECURITY: Rotate every 90 days - see docs/security.md for rotation procedure
GITHUB_TOKEN_ENCRYPTION_KEY=your_encryption_key_at_least_32_chars_recommended_64_plus

# GitHub Token Refresh Configuration
# Time in seconds before token expiry to trigger automatic refresh
# Default: 3600 (1 hour) - tokens expiring within this window will be refreshed
# Increase this value during high-traffic periods to avoid issuing near-expired tokens
# Valid range: 300-7200 seconds (5 minutes to 2 hours)
GITHUB_TOKEN_REFRESH_THRESHOLD_SECONDS=3600

# GitHub Token Encryption Key Rotation
# Number of days between required encryption key rotations
# Default: 90 days (recommended for production)
# Set to 0 to disable rotation warnings
GITHUB_TOKEN_ENCRYPTION_KEY_ROTATION_INTERVAL_DAYS=90

# Redis Configuration
# Redis is required for multi-instance deployments (Cloud Run autoscaling, Kubernetes)
# Stores OAuth state tokens to support load-balanced authentication flows

# Redis host (use private IP or hostname for production)
# For Cloud Memorystore: Use the instance's IP address
REDIS_HOST=localhost

# Redis port (default: 6379)
REDIS_PORT=6379

# Redis password (optional, leave empty for no auth in development)
# For production, always use a strong password
REDIS_PASSWORD=

# Redis database number (0-15, default: 0)
REDIS_DB=0

# Redis connection timeout in milliseconds (default: 5000)
REDIS_CONNECT_TIMEOUT_MS=5000

# Redis max connection retries (default: 3)
REDIS_MAX_RETRIES=3

# Redis retry delay in milliseconds (default: 1000)
REDIS_RETRY_DELAY_MS=1000

# Redis max retries per request (default: 3)
REDIS_MAX_RETRIES_PER_REQUEST=3

# Redis state TTL in seconds (default: 600 = 10 minutes)
# OAuth states expire after this duration
# Should match or exceed SESSION_MAX_AGE_MS
REDIS_STATE_TTL_SECONDS=600

# Session Configuration
SESSION_SECRET=your_session_secret_here_minimum_32_characters_recommended
SESSION_MAX_AGE_MS=600000

# UI Configuration
ADMIN_CONTACT_EMAIL=admin@example.com
ADMIN_CONTACT_NAME=Administrator

# JWT Configuration
# REQUIRED: RSA private key for signing JWTs (base64-encoded PEM format)
# Generate keys with: 
#   openssl genpkey -algorithm RSA -out jwt-private.pem -pkeyopt rsa_keygen_bits:2048
#   openssl rsa -pubout -in jwt-private.pem -out jwt-public.pem
# Then base64 encode:
#   base64 -w 0 jwt-private.pem  (Linux)
#   base64 -i jwt-private.pem -o - (macOS)
# SECURITY: Never commit private key to source control
# SECURITY: Rotate every 180 days - see docs/security.md for rotation procedure
JWT_PRIVATE_KEY=base64_encoded_rsa_private_key_in_pem_format
# REQUIRED: RSA public key for verifying JWTs (base64-encoded PEM format)
JWT_PUBLIC_KEY=base64_encoded_rsa_public_key_in_pem_format
# JWT Key Rotation Policy
# Number of days between required key rotations
# Default: 180 days (recommended for production)
# Set to 0 to disable rotation warnings
JWT_KEY_ROTATION_INTERVAL_DAYS=180
# JWT expiration time - controls how long JWTs remain valid before expiring
# Format: number followed by unit (s=seconds, m=minutes, h=hours, d=days)
# Examples: 30d (30 days), 7d (7 days), 24h (24 hours), 60m (60 minutes), 3600s (3600 seconds)
# Default: 30d (30 days)
# Minimum: 60s (60 seconds) - values below this will cause startup errors
# Recommended minimum for production: 5m (5 minutes) to avoid UX issues
# Warning threshold: Values below 5m will trigger startup warnings
# Maximum recommended: 90d (90 days) - longer values may pose security risks
# IMPORTANT: Both token claims (exp) and API response fields will reflect this value
JWT_EXPIRES_IN=30d
# JWT issuer (typically your service URL)
JWT_ISSUER=http://localhost:3000
# JWT audience (typically your service URL or consumer services)
JWT_AUDIENCE=http://localhost:3000
# Clock tolerance in seconds for JWT validation (handles clock skew)
JWT_CLOCK_TOLERANCE_SECONDS=60

# Rate Limiting Configuration
# Rate limits are enforced per IP address using Redis for distributed counting
# Authentication endpoints (strict limits to prevent brute force)
RATE_LIMIT_AUTH_WINDOW_MS=900000
RATE_LIMIT_AUTH_MAX=10
# JWT endpoints (moderate limits for token operations)
RATE_LIMIT_JWT_WINDOW_MS=900000
RATE_LIMIT_JWT_MAX=100
# GitHub token endpoint (higher limits for service-to-service calls)
RATE_LIMIT_GITHUB_TOKEN_WINDOW_MS=3600000
RATE_LIMIT_GITHUB_TOKEN_MAX=1000

# Cookie Security Configuration
# HttpOnly flag prevents JavaScript access to cookies
COOKIE_HTTP_ONLY=true
# Secure flag ensures cookies are only sent over HTTPS (disable for local dev)
COOKIE_SECURE=false
# SameSite attribute prevents CSRF attacks (strict, lax, or none)
COOKIE_SAME_SITE=strict

# Security Headers Configuration
# Content-Security-Policy (CSP) - Mitigates XSS and data injection attacks
# 
# NONCE-BASED CSP: The service automatically generates cryptographically secure nonces
# for each request to protect inline scripts and styles. Nonces are:
# - Generated per request (16 random bytes, base64-encoded)
# - Automatically injected into script-src and style-src directives
# - Applied to all inline <script> and <style> tags in rendered pages
# - Eliminate the need for 'unsafe-inline', significantly improving XSS protection
#
# Set CSP_ENABLED=false to disable CSP (not recommended for production)
CSP_ENABLED=true
# CSP directives (comma-separated values)
# default-src: Fallback for all resource types
CSP_DEFAULT_SRC='self'
# script-src: JavaScript sources
# Note: Nonces are automatically injected per-request. Do NOT add 'unsafe-inline'.
# If you must override, nonces will be automatically added when available.
CSP_SCRIPT_SRC='self'
# style-src: CSS sources
# Note: Nonces are automatically injected per-request. Do NOT add 'unsafe-inline'.
# If you must override, nonces will be automatically added when available.
CSP_STYLE_SRC='self'
# img-src: Image sources
CSP_IMG_SRC='self',data:,https:
# connect-src: AJAX/fetch/WebSocket sources (includes GitHub OAuth)
# CSP_CONNECT_SRC='self',https://github.com
# font-src: Font sources
CSP_FONT_SRC='self',data:
# object-src: <object>, <embed>, <applet> sources
CSP_OBJECT_SRC='none'
# media-src: <audio>, <video> sources
CSP_MEDIA_SRC='self'
# frame-src: <iframe> sources
CSP_FRAME_SRC='none'
# form-action: Form submission targets (includes GitHub OAuth)
CSP_FORM_ACTION='self',https://github.com
# frame-ancestors: Embedding restrictions (prevents clickjacking)
CSP_FRAME_ANCESTORS='none'
# base-uri: <base> element URLs
CSP_BASE_URI='self'
# upgrade-insecure-requests: Automatically upgrade HTTP to HTTPS (production only)
CSP_UPGRADE_INSECURE_REQUESTS=true

# HTTP Strict Transport Security (HSTS) - Forces HTTPS
# Automatically disabled in development, enabled in production
# Set HSTS_ENABLED=false to disable HSTS explicitly
HSTS_ENABLED=true
# HSTS max age in seconds (default: 31536000 = 1 year)
HSTS_MAX_AGE=31536000
# Include subdomains in HSTS policy
HSTS_INCLUDE_SUBDOMAINS=true
# Submit domain to browser HSTS preload list (requires max-age >= 1 year)
HSTS_PRELOAD=false

# X-Frame-Options - Prevents clickjacking attacks
# Values: DENY (no framing), SAMEORIGIN (same origin only)
X_FRAME_OPTIONS=DENY

# X-Content-Type-Options - Prevents MIME sniffing
# Set to false to disable (not recommended)
X_CONTENT_TYPE_OPTIONS=true

# Referrer-Policy - Controls referrer information sent with requests
# Values: no-referrer, no-referrer-when-downgrade, origin, origin-when-cross-origin,
#         same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
REFERRER_POLICY=strict-origin-when-cross-origin

# Permissions-Policy - Controls browser feature access
# Values are comma-separated origins, or empty for no access
# camera: Camera access
PERMISSIONS_POLICY_CAMERA=
# microphone: Microphone access
PERMISSIONS_POLICY_MICROPHONE=
# geolocation: Geolocation access
PERMISSIONS_POLICY_GEOLOCATION=
# payment: Payment API access
PERMISSIONS_POLICY_PAYMENT=
# usb: USB device access
PERMISSIONS_POLICY_USB=

# CORS (if needed for API access from other origins)
# CORS_ORIGIN=http://localhost:3000

# Service API Key Rotation Policy
# Number of days between required service API key rotations
# Default: 365 days (recommended for production)
# Set to 0 to disable rotation warnings
SERVICE_API_KEY_ROTATION_INTERVAL_DAYS=365

# Prometheus Metrics Configuration
# Enable/disable Prometheus metrics collection
METRICS_ENABLED=true
# Metric name prefix (e.g., af_auth_http_requests_total)
METRICS_PREFIX=af_auth_
# Namespace for default labels
METRICS_NAMESPACE=af_auth
# Collect default Node.js metrics (CPU, memory, event loop, etc.)
METRICS_COLLECT_DEFAULT=true
# Metrics endpoint path
METRICS_ENDPOINT=/metrics
# Optional: Bearer token for metrics endpoint authentication
# Generate with: openssl rand -hex 32
# If not set, metrics endpoint is public (NOT recommended for production)
# METRICS_AUTH_TOKEN=your_metrics_auth_token_here

# Cloud Run Configuration (when deploying to GCP)
# K_SERVICE=af-auth
# K_REVISION=af-auth-00001-abc
# K_CONFIGURATION=af-auth

# Terraform Deployment Configuration
# These variables are used by Terraform for infrastructure provisioning
# See infra/terraform/ for deployment instructions

# TF_VAR_project_id=your-gcp-project-id
# TF_VAR_region=us-central1
# TF_VAR_environment=production
# TF_VAR_container_image=us-central1-docker.pkg.dev/project/af-auth/af-auth:latest
# TF_VAR_database_password=USE_SECRET_MANAGER_NOT_THIS

# Terraform state backend (for remote state storage)
# GCP: gs://your-terraform-state-bucket/terraform/af-auth
# AWS: s3://your-terraform-state-bucket/af-auth/terraform.tfstate
# Azure: azurerm://storage-account/container/af-auth.tfstate
# Local: terraform.tfstate (for development/testing only)
